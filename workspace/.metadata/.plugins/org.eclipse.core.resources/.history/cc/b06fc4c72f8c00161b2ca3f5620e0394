/*
 * Inicializaciones.c
 *
 *  Created on: 7 de oct. de 2016
 *      Author: Pablo
 */


#include "header.h"


void dma_init()
{
	static char init_flag = 0;

	if(!init_flag)
	{
		Chip_GPDMA_Init(LPC_GPDMA);

		NVIC_DisableIRQ(DMA_IRQn);


		#ifdef USE_ADC
			/*dma_channel_adc =*/ Chip_GPDMA_GetFreeChannel(LPC_GPDMA , 0);
			Chip_GPDMA_PrepareDescriptor(LPC_GPDMA, &DMA_descriptor_ADC,
											(uint32_t) GPDMA_CONN_ADC, (uint32_t) dma_memory_adc,
											ADC_DMA_CANT_MUESTRAS, GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA, NULL);
			DMA_descriptor_ADC.src = GPDMA_CONN_ADC;
		#endif

		#ifdef USE_DAC
			/*dma_channel_dac =*/ Chip_GPDMA_GetFreeChannel(LPC_GPDMA , 0);
			Chip_GPDMA_PrepareDescriptor(LPC_GPDMA, &DMA_descriptor_DAC,
											(uint32_t) dma_memory_adc, (uint32_t) GPDMA_CONN_DAC,
											DAC_DMA_CANT_MUESTRAS, GPDMA_TRANSFERTYPE_M2P_CONTROLLER_DMA, NULL);
			DMA_descriptor_DAC.dst = GPDMA_CONN_DAC;
		#endif

		// Setting GPDMA interrupt
		NVIC_EnableIRQ(DMA_IRQn);

		init_flag = 1;
	}
}

#ifdef USE_UART
	void uart_init()
	{
		Board_UART_Init((uint32_t)LPC_UART0, 9600);

		// Before using the ring buffers, initialize them using the ring
		// buffer init function
		RingBuffer_Init(&rxring, rxbuff, 1, UART_RRB_SIZE);
		RingBuffer_Init(&txring, txbuff, 1, UART_SRB_SIZE);

		// Enable receive data and line status interrupt
		Chip_UART_IntEnable(LPC_UART0, (UART_IER_RBRINT | UART_IER_RLSINT));

		/* preemption = 1, sub-priority = 1 */
		NVIC_SetPriority(UART0_IRQn, 1);
		NVIC_EnableIRQ(UART0_IRQn);

		const char Uart_init_msg[] = "\r\nHola mundo:\r\n";

		/* Envia mensaje inicial por UART*/
		Chip_UART_SendRB(LPC_UART0, &txring, Uart_init_msg, sizeof(Uart_init_msg));


			// Inicializacion de colas
		xQueue_in = xQueueCreate(QUEUE_LEN_IN, QUEUE_ITEM_SIZE_IN);
		xQueue_rem = xQueueCreate(QUEUE_LEN_REM, QUEUE_ITEM_SIZE_REM);
		xQueue_THD = xQueueCreate(QUEUE_LEN_THD, QUEUE_ITEM_SIZE_THD);

		xTaskCreate(vTask_THD, "vTask_THD", configMINIMAL_STACK_SIZE, NULL, (tskIDLE_PRIORITY + 1UL),
				(xTaskHandle *) NULL);
	}
#endif

void fft_init()
{
		// Asigno la direccion en memoria
		//mSignalIn     = (int16_t *) 0x2007C000;
		//mFFTOut       = (int16_t *)(0x2007C000 + LENGTH_SAMPLES * sizeof(int16_t));

		memset(mSignalIn, 	0, sizeof(int16_t) * LENGTH_SAMPLES );	//Inicializo en 0 la entrada
		memset(mFFTOut, 	0, sizeof(int16_t) * LENGTH_SAMPLES);		//Inicializo en 0 la salida

//		// Seno -- // Arma el seno de prueba (completa solo la parte real)
//		for(indice=0; indice < FFT_SIZE ; indice++)
//			mSignalIn[indice*2] = seno[indice];

}

#ifdef USE_ADC
	void adc_init()
	{
		dma_init();

		ADC_CLOCK_SETUP_T adc;

		Chip_ADC_Init(LPC_ADC, &adc);
		Chip_ADC_SetSampleRate(LPC_ADC, &adc, 10000);
		Chip_ADC_EnableChannel(LPC_ADC, ADC_CH0, ENABLE);
		Chip_ADC_Int_SetChannelCmd(LPC_ADC, ADC_CH0, ENABLE);
		Chip_ADC_SetBurstCmd(LPC_ADC, ENABLE);
		//Chip_ADC_SetStartMode(LPC_ADC, ADC_START_NOW, ADC_TRIGGERMODE_RISING);
	}
#endif

#ifdef USE_DAC
	void dac_init()
	{
		dma_init();

		Chip_DAC_Init(LPC_DAC);

		// (SystemCoreClock/4) / ( DAC_FREQ * DAC_DMA_CANT_MUESTRAS ); // Fija la separacion entre muestras.

		Chip_DAC_SetDMATimeOut(LPC_DAC, (SystemCoreClock/4) / (20000 * DAC_DMA_CANT_MUESTRAS) ); // Se configura el TimeOut.
		//Chip_DAC_SetDMATimeOut(LPC_DAC, 20000 ); // Se configura el TimeOut.

		Chip_DAC_ConfigDAConverterControl(LPC_DAC, DAC_DBLBUF_ENA | DAC_CNT_ENA | DAC_DMA_ENA); // Se habilita el DMA y soporte de cuenta.
	}
#endif

void main_init()
{
	SystemCoreClockUpdate();

	Board_Init();

	#ifdef USE_UART
		uart_init();
	#endif

	#ifdef USE_ADC
		adc_init();
	#endif

	#ifdef USE_DAC
		dac_init();
	#endif

	//fft_init();


	Chip_GPDMA_Transfer(LPC_GPDMA, dma_channel_adc,
							(uint32_t) (GPDMA_CONN_ADC), (uint32_t) dma_memory_adc,
							GPDMA_TRANSFERTYPE_P2M_CONTROLLER_DMA, ADC_DMA_CANT_MUESTRAS);


	// Start the scheduler so the created tasks start executing.
	// vTaskStartScheduler();
}
